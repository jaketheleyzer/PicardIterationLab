# -*- coding: utf-8 -*-
"""Calc4 Comp Lab 2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sjgneUZMKu0pxcBDNgy27-Lz1WH3uF0R
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import math

#Excercise 1

def integrate_riemann(funciton_F, initTime, t, intN):
  sum = 0
  for n in range(intN+1):
      sum += funciton_F(initTime + (t-initTime)*(n/intN))
  return ((t-initTime)/intN)* sum

#Exercise 2

def picard(function_v, function_xj, initTime, time, intN):
    integrand = lambda t: function_v(function_xj(t), t)
    return initTime + integrate_riemann(integrand, initTime, time, intN)

"""Taking t₀ = 0 and N = 100"""

initTime=0
intN =100

def v(x, t):
   return x * math.cos(t)

#Exercise 3

x0 = lambda t :1
x1 = lambda t: picard(v, x0, initTime, t, intN)
x2 = lambda t: picard(v, x1, initTime, t, intN)
x3 = lambda t: picard(v, x2, initTime, t, intN)
x4 = lambda t: picard(v, x3, initTime, t, intN)

print(x1(1))
print(x2(1))
print(x3(1))
print(x4(1))

#Exercise 4

def interpolate(t, Y, T):
  n = -1
  for i in range(len(T) - 1):
    if T[i] <= t < T[i + 1]:
      n = i
      break

  return Y[n] + ((t-T[n])/(T[n+1]-T[n])) * (Y[n+1] - Y[n])

#Exercise 5

def integrate_riemann_interpolated(function_v, Y, t0, t, N, T):
    dt = (t - t0) / N
    total = 0.0

    for n in range(N):
        current_time = t0 + n * dt
        x_val = interpolate(current_time, Y, T)
        total += function_v(x_val, current_time)

    return dt * total

#Exercise 6

def picard_interpolated(function_v, Y, initx, initTime, intN, T):
    X = []
    for t_val in T:
        integral = integrate_riemann_interpolated(function_v, Y, initTime, t_val, intN, T)
        X.append(initx + integral)
    return X

initTime=0
intN =100
finalTime = 2*math.pi
T = np.linspace(initTime, finalTime, intN)

# Exercise 7


x0 = lambda t: 1
Y = np.full_like(T, x0(initTime), dtype=float)
picard_iterates = [Y]

for i in range(10):
    Y_new = picard_interpolated(v, Y, x0(initTime), initTime, intN, T)
    Y = Y_new
    picard_iterates.append(Y_new)

actual = np.exp(np.sin(T))

plt.figure(figsize=(10, 6))
plt.plot(T, actual, label='Exact: $e^{\sin(t)}$', color='black', linewidth=1.2)
plt.plot(T, picard_iterates[0], label='x₀(t)', linestyle='--')
plt.plot(T, picard_iterates[5], label='x₅(t)', linestyle='-.')
plt.plot(T, picard_iterates[10], label='x₁₀(t)', linestyle='-')
plt.plot(T, actual, label='Exact: $e^{\sin(t)}$', color='black', linewidth=1.2)
plt.legend()
plt.xlabel('t')
plt.ylabel('x(t)')
plt.title('Picard Iterations (N = 100)')
plt.grid(True)
plt.show()

intN = 1000

x0 = lambda t :1


picard_iterates = []

current_iterate = x0

for i in range(10):
    Y = [current_iterate(t) for t in T]

    next_iterate_values = picard_interpolated(v, Y, x0(initTime), initTime, intN, T)

    current_iterate = lambda t, iv=next_iterate_values: np.interp(t, T, iv)
    picard_iterates.append(current_iterate)

time = np.arange(0, 2*math.pi, 0.01)
actual = np.exp(np.sin(time))
plt.plot(time, actual)
picard_x0 = [x0(t) for t in time]
picard_x5 = [picard_iterates[4](t) for t in time]
picard_x10 = [picard_iterates[9](t) for t in time]
plt.plot(time, picard_x0,'--')
plt.plot(time, picard_x5,'--')
plt.plot(time, picard_x10,'--')


plt.title("Picard Iteration vs Actual Solution")
plt.xlabel("Time")
plt.ylabel("x Values")
plt.legend(["Actual Solution", "Picard Approximation x0(t)","Picard Approximation x5(t)", "Picard Approximation x10(t)"])
plt.show()